# Valgrind Exercise

## Standard install via command-line

```bash
# Configure the project and generate a native build system:
  # Must re-run this command whenever any CMakeLists.txt file has been changed.
  cmake -S ./ -B build/
# Compile and build the project:
  # rebuild only files that are modified since the last build
  cmake --build build/
  # or rebuild everything from scracth
  cmake --build build/ --clean-first
  # to see verbose output, do:
  cmake --build build/ --verbose
# Run program:
  ./build/app/shell-app
# Clean
  cmake --build build/ --target clean
# Clean and start over:
  rm -rf build/
```

## Valgrind

For the results generated by valgrind before the bug fixes open the file `valgrind_bug_report.txt` in the `results` folder.

Bugs found:

1. Conditional jump or move depends on uninitialised value(s)
2. Heap leak summary

For the results generated by valgrind after the bug fixes open the file `valgrind_fix_report.txt` in the `results` folder.

For the results generated by valgrind during static linking open the file `valgrind_static_run.txt` in the `results` folder.

## Extra Credit

What happens when the executable is linked statically?  Does Valgrind still detect those same bugs?

Yes, Valgrind still detects the same bugs but it does so recursively. The same bug is repeated again and again.

Along with the bugs, Valgrind also detects the following error: `Use of uninitialised value of size 8` as the program tries to access the memory that is already allocated.

Unlike the dynamic linking, the static linking does not show the error `leaks in heap memory`.
